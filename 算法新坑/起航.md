## 前言
### 算法
- 定义问题是明确的，包含清晰的输入和输出定义。
- 具有可行性，能够在有限步骤、时间和内存空间下完成。
- 各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。

### 数据结构
*数据结构（data structure）是组织和存储数据的方式，涵盖数据内容、数据之间关系和数据操作方法，它具有以下设计目标。*
- 空间占用尽量少，以节省计算机内存。
- 数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。
- 提供简洁的数据表示和逻辑信息，以便算法高效运行。

*数据结构设计是一个充满权衡的过程*如果想在某方面取得提升，往往需要在另一方面作出妥协。下面举两个例子。
- 链表相较于数组，在数据添加和删除操作上更加便捷，但牺牲了数据访问速度。
- 图相较于链表，提供了更丰富的逻辑信息，但需要占用更大的内存空间。

### 数据结构与算法的关系
- 数据结构是算法的基石。数据结构为算法提供了结构化*存储的数据*，以及操作数据的方法。
- 算法是数据结构*发挥作用*的舞台。数据结构本身仅存储数据信息，结合算法才能解决特定问题。
- 算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。
![数据结构与算法的关系](https://www.hello-algo.com/chapter_introduction/what_is_dsa.assets/relationship_between_data_structure_and_algorithm.png)
ps.在实际讨论时，我们通常会将“数据结构与算法”简称为“算法”。比如众所周知的 LeetCode 算法题目，实际上同时考查数据结构和算法两方面的知识。

## 复杂度分析
### 算法效率评估
- 时间效率：算法运行时间的长短。
- 空间效率：算法占用内存空间的大小。

简而言之，我们的目标是设计“既快又省”的数据结构与算法。而有效地评估算法效率至关重要，因为只有这样，我们才能将各种算法进行对比，进而指导算法设计与优化过程。

效率评估方法主要分为两种：实际测试、理论估算。

*实际测试*：
假设我们现在有算法 A 和算法 B ，它们都能解决同一问题，现在需要对比这两个算法的效率。最*直接的方法是找一台计算机*，运行这两个算法，并监控记录它们的运行时间和内存占用情况。这种评估方式能够反映真实情况，但也存在较大的局限性。

一方面，难以排除测试环境的干扰因素。硬件配置会影响算法的性能表现。比如*一个算法的并行度较高*，那么它就更适合在多核 CPU 上运行，*一个算法的内存操作密集*，那么它在高性能内存上的表现就会更好。也就是说，算法在不同的机器上的测试结果可能是不一致的。这意味着我们需要在各种机器上进行测试，统计平均效率，而这是不现实的。

另一方面，展开完整测试非常耗费资源。*随着输入数据量的变化*，算法会表现出不同的效率。例如，在输入数据量较小时，算法 A 的运行时间比算法 B 短；而在输入数据量较大时，测试结果可能恰恰相反。因此，为了得到有说服力的结论，我们需要测试各种规模的输入数据，而这需要耗费大量的计算资源。

### 迭代与递归
迭代（iteration）是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。
#### for循环
for 循环是最常见的迭代形式之一，*适合在预先知道迭代次数时使用。*
- 此求和函数的操作数量与输入数据大小 
 成正比，或者说成“线性关系”。实际上，时间复杂度描述的就是这个“线性关系”。相关内容将会在下一节中详细介绍。（个人理解for循环就是一个n）

#### while循环
与 for 循环类似，while 循环也是一种实现迭代的方法。在 while 循环中，*程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环*。

#### 嵌套循环
```js
/* 双层 for 循环 */
function nestedForLoop(n) {
    let res = '';
    // 循环 i = 1, 2, ..., n-1, n
    for (let i = 1; i <= n; i++) {
        // 循环 j = 1, 2, ..., n-1, n
        for (let j = 1; j <= n; j++) {
            res += `(${i}, ${j}), `;
        }
    }
    return res;
}
```
在这种情况下，函数的操作数量与 n^2
 成正比，或者说算法运行时间和输入数据大小 
 成“平方关系”。

我们可以继续添加嵌套循环，每一次嵌套都是一次“升维”，将会使时间复杂度提高至“立方关系”“四次方关系”，以此类推。

#### 递归
递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。
1. 递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。
2. 归：触发“终止条件”后，程序*从最深层的递归函数开始逐层返回，汇聚每一层的结果*。
- 而从实现的角度看，递归代码主要包含三个要素。
1. 终止条件：用于决定什么时候由“递”转“归”。
2. 递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数。
3. 返回结果：对应“归”，将*当前递归层级的结果*返回至上一层。
```js
/* 递归 */
function recur(n) {
    // 终止条件
    if (n === 1) return 1;
    // 递：递归调用
    const res = recur(n - 1);
    // 归：返回结果
    return n + res;
}
```
![递归图示](https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/recursion_sum.png)

虽然从计算角度看，迭代与递归可以得到相同的结果，但它们代表了两种完全不同的思考和解决问题的范式。

- 迭代：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。
- 递归：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。

1. 调用栈

    递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。
    - 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，*递归通常比迭代更加耗费内存空间*。
    - 递归调用函数会产生额外的开销。因此*递归通常比循环的时间效率更低*。

如图所示，在触发终止条件前，同时存在n个未返回的递归函数，递归深度为n。
![递归图示2](https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/recursion_sum_depth.png)

在实际中，编程语言允许的递归深度通常是有限的，*过深的递归可能导致栈溢出错误*。

2. 有趣的是，如果**函数在返回前的最后一步才进行递归调用**，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。
![尾递归](https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/tail_recursion_sum.png)
- 请注意，许多编译器或解释器并不支持尾递归优化。例如，Python 默认不支持尾递归优化，因此即使函数是尾递归形式，仍然可能会遇到栈溢出问题。(我在node和浏览器里用js貌似也不行，都溢出了)

  3. 递归树
    当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。以“斐波那契数列”为例。
```js
var fib = function (n) {
  if (n === 0) return 0;
  if (n === 1) return 1;
  return fib(n - 1) + fib(n - 2);
};
fib(5);
```

观察以上代码，我们在*函数内递归调用了两个函数*，这意味着从一个调用产生了两个调用分支。如图所示，这样不断递归调用下去，最终将产生一棵层数为n的递归树（recursion tree）。

    - 从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。

- 从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。
- 从数据结构角度看，递归天然适合处理**链表、树和图**的相关问题，因为它们非常适合用分治思想进行分析。

### 时间复杂度
ps. 备注：a是x，N是y，多少个小a相乘可以的得到大y？logxY
![对数图像](https://tse2-mm.cn.bing.net/th/id/OIP-C.V86KbLALYHSV90ciTQjPAgHaDp?rs=1&pid=ImgDetMain)
- 推算方法
1. 统计操作数量
    1. 忽略常数项
    2. 省略所有系数（2n+1，5n+1 都算n）
    3. 循环嵌套时使用乘法
2. 判断渐进上界
    趋紧极值

#### 常见类型
1. 常数阶O(1)
```js
/* 常数阶 */
// 无论size多大
function constant(n) {
    let count = 0;
    const size = 100000;
    for (let i = 0; i < size; i++) count++;
    return count;
}
```
2. 线性阶O(n)
```js
/* 线性阶 */
function linear(n) {
    let count = 0;
    for (let i = 0; i < n; i++) count++;
    return count;
}
```
3. 平方阶O(n^2) ,代码就是for嵌套
4. 指数阶O(2^n),和对数阶正好相反
```js
/* 指数阶（循环实现） */
// 外层n控制内部轮数，内部控制一轮循环次数实现2^n
function exponential(n) {
    let count = 0,
        base = 1;
    // 细胞每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1)
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < base; j++) {
            count++;
        }
        base *= 2;
    }
    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1
    return count;
}
```
![指数阶](https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_exponential.png)
5. 对数阶O(log n)
```js
// 与指数阶相反，每轮需要循环次数会缩减到之前的一半
// 循环n次为基准，每次循环体会缩减一半的循环上限
/* 对数阶（循环实现） */
function logarithmic(n) {
    let count = 0;
    while (n > 1) {
        n = n / 2;
        count++;
    }
    return count;
}
```
![对数阶段](https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_logarithmic.png)
ps. 对数阶常出现于基于分治策略的算法中，体现了“一分为多”和“化繁为简”的算法思想。它增长缓慢，是*仅次于常数阶的理想的时间复杂度*。

6. nlogn以及n!全排列，等后续懂了再继续

#### 最差、最佳、平均时间复杂度
- 算法的时间效率往往不是固定的，而是与输入数据的分布有关。nums数组，有1到n到所有数字，每个出现一次。元素是随机打乱的，如果想要输出1，则会出现：
    - [?,?,...,1]，即完整遍历一次数组，达到最差时间复杂度,时间复杂度O(n)
    - [1,...]，第一个就是，达到最佳时间复杂度O(1)
    - 值得说明的是，我们在实际中*很少使用最佳时间复杂度*，因为通常只有在很小概率下才能达到，可能会带来一定的误导性。而最*差时间复杂度更为实用，因为它给出了一个效率安全值*，让我们可以放心地使用算法。

### 空间复杂度
算法在运行过程中使用的内存空间主要包括以下几种。
- 输入空间：用于存储算法的输入数据。
- 暂存空间：用于存储算法在运行过程中的变量、对象、函数上下文等数据。
- 输出空间：用于存储算法的输出数据。

一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。

暂存空间可以进一步划分为三个部分。
- 暂存数据：用于保存算法运行过程中的各种常量、变量、对象等。
- 栈帧空间：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。
- 指令空间：用于保存编译后的程序指令，在实际统计中通常忽略不计。
```js
function algorithm(n) {       // 输入数据
    const a = 0;              // 暂存数据（常量）
    let b = 0;                // 暂存数据（变量）
    const node = new Node(0); // 暂存数据（对象）
    const c = constFunc();    // 栈帧空间（调用函数）
    return a + b + c;         // 输出数据
}
```

## 数据结构
### 逻辑结构：线性与非线形
![线性数据结构与非线性数据结构](https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_logic_structure.png)

### 物理结构：连续与分散
![物理结构内存](https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/computer_memory_location.png)

*值得说明的是，将内存比作 Excel 表格是一个简化的类比，实际内存的工作机制比较复杂，涉及地址空间、内存管理、缓存机制、虚拟内存和物理内存等概念。*

如图所示，物理结构反映了数据在计算机内存中的存储方式，可分为*连续空间存储（数组）*和*分散空间存储（链表）*。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。
![物理存储](https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_phisical_structure.png)
- 值得说明的是，所有数据结构都是基于数组、链表或二者的组合实现的。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。
  - 基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 >=3的数组）等。
  - 基于链表可实现：栈、队列、哈希表、树、堆、图等。
- 链表在初始化后，仍可以在程序运行过程中对其长度进行调整，因此也称“动态数据结构”。数组在初始化后长度不可变，因此也称“静态数据结构”。值得注意的是，数组可通过重新分配内存实现长度变化，从而具备一定的“动态性”。

#### UTF-8编码
![utf-8](https://www.hello-algo.com/chapter_data_structure/character_encoding.assets/utf-8_hello_algo.png)
- 对于长度为 1 字节的字符，将最高位设置为 
0，其余 7 位设置为 Unicode 码点。值得注意的是，ASCII 字符在 Unicode 字符集中占据了前 128 个码点。也就是说，UTF-8 编码可以向下兼容 ASCII 码。这意味着我们可以使用 UTF-8 来解析年代久远的 ASCII 码文本。
- 大于1字节的见上图
- ps.GBK -> Unicode（默认全部两字节，包括字母和半角符号） -> UTF-8